MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=BlockBoundaryString12345AbCdE

--BlockBoundaryString12345AbCdE
Content-Type: text/cloud-config

repo_update: false
repo_upgrade: none
bootcmd:
    {% if 'NameServers' in context %}
    - 'echo "# DNS resolver configuration" > /etc/resolv.conf'
    - 'echo -e "# Generated by the pipeline\n" >> /etc/resolv.conf'
    {% for nameserver in context.NameServers %}
    - 'echo "nameserver {{ nameserver }}" >> /etc/resolv.conf'
    {% endfor %}
    {% endif %}
    - 'echo "options timeout:2 attempts:3" >> /etc/resolv.conf'
    - 'uptime'
    - 'exit 0'

--BlockBoundaryString12345AbCdE
Content-Type: text/x-shellscript

#!/bin/bash
set -ex

# log everything here to user-data
exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1
PORTFOLIO="{{ context.Portfolio }}"
ENV="{{ context.Branch }}"
if [[ "$ENV" == "prod" ]];then
  SHORT_ENV="prd"
elif [["$ENV" == "nonprod" ]];then
  SHORT_ENV="nprd"
else
  SHORT_ENV="dev"
fi
# Function to fetch instance ID using IMDSv1
fetch_instance_id_v1() {
    curl -s http://169.254.169.254/latest/meta-data/instance-id
}

# Function to fetch instance ID using IMDSv2
fetch_instance_id_v2() {
     TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
     if [ -n "$TOKEN" ]; then
         curl -H "X-aws-ec2-metadata-token: $TOKEN" -s http://169.254.169.254/latest/meta-data/instance-id
     else
         # Fall back to IMDSv1 if token fetch fails
         fetch_instance_id_v1
     fi
}

# Attempt to fetch instance ID using IMDSv2, fall back to IMDSv1 if necessary
INSTANCE_ID="$(fetch_instance_id_v2)"
INSTANCE_SUFFIX="$(echo $INSTANCE_ID | awk -F'-' '{print $NF}')"

# Construct the new hostname
NEW_HOSTNAME="$(echo $PORTFOLIO | awk -F'-' '{print $NF}')$SHORT_ENV$INSTANCE_SUFFIX"

# Set the hostname
hostnamectl set-hostname $NEW_HOSTNAME

# Restart services to apply the new hostname
systemctl restart rsyslog.service
signal () {
    EXIT_CODE=$?
    [ $EXIT_CODE -eq 0 ] || echo "=== End Userdata - FAILED ==="
    /opt/aws/bin/cfn-signal --region ${AWS::Region} --stack ${AWS::StackName} --resource AutoScalingGroup --exit-code $EXIT_CODE
}
trap signal EXIT

echo "=== Begin Userdata ==="

# Source the profile scripts for this session
mkdir -p /etc/profile.d || true
if [ ! -f /etc/profile.d/proxy.sh ];then
echo "# Proxy configuration" > /etc/profile.d/proxy.sh
echo -e "# Generated by the pipeline\n" >> /etc/profile.d/proxy.sh
if [ -n "{{ context.ProxyUrl }}" ]; then
    echo "export http_proxy='{{ context.ProxyUrl }}'" >> /etc/profile.d/proxy.sh
    echo "export https_proxy='{{ context.ProxyUrl }}'" >> /etc/profile.d/proxy.sh
    echo "export HTTP_PROXY='{{ context.ProxyUrl }}'" >> /etc/profile.d/proxy.sh
    echo "export HTTPS_PROXY='{{ context.ProxyUrl }}'" >> /etc/profile.d/proxy.sh
    echo "export no_proxy='{{ context.NoProxy }}'" >> /etc/profile.d/proxy.sh
    echo "export NO_PROXY='{{ context.NoProxy }}'" >> /etc/profile.d/proxy.sh
fi
fi

if [ ! -f /etc/profile.d/deployment_information.sh ];then
echo "# Deployment information" > /etc/profile.d/deployment_information.sh
echo -e "# Generated by the pipeline\n" >> /etc/profile.d/deployment_information.sh

echo "export PIPELINE_AWS_REGION=${AWS::Region}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_AWS_ACCOUNT_ID=${AWS::AccountId}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_ENVIRONMENT={{ context.Environment }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_KMS_KEY_ARN=${KmsKeyArn}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_PORTFOLIO={{ context.Portfolio }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_APP={{ context.App }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_BRANCH={{ context.Branch }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_BRANCH_SHORT_NAME={{ context.BranchShortName }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_BUILD={{ context.Build }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_COMPONENT={{ component_name }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_BUCKET_NAME={{ context.FilesBucketName }}" >> /etc/profile.d/deployment_information.sh
echo "export PIPELINE_BUCKET_BUILD_PREFIX={{ context.BuildFilesPrefix }}" >> /etc/profile.d/deployment_information.sh
fi
source /etc/profile.d/proxy.sh
source /etc/profile.d/deployment_information.sh

# Print environment variables for debugging
env

# Per-distro tweaks before running cfn-init.
{% include "AWS/_shared/userdata/distro.sh" %}

echo "Executing cfn-init"
tail -F /var/log/cfn-init.log --pid $$ -q &
/opt/aws/bin/cfn-init --region ${AWS::Region} --stack ${AWS::StackName} --resource launchTemplate --configsets default

python /tmp/awslog_convert.py -a /var/awslogs -o /tmp/config.json -r {{ context.AwsRegion }}
/opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a append-config -m ec2 -s -c file:/tmp/config.json


echo "=== End Userdata - SUCCESS ==="
