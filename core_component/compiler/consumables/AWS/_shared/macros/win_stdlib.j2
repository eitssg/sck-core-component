{% macro win_stdlib() %}
function Expand-ZIPFile {
    Param (
        [string]$File,
        [string]$Destination
    )
    $shell = New-Object -Com shell.application
    $zip = $shell.NameSpace($File)
    Foreach ($item in $zip.items()) {
        $shell.Namespace($Destination).copyhere($item,0x14)
    }
}
function Invoke-HttpRequest{
    Param (
        [Parameter(Mandatory=$true)] $request,
        [Parameter(Mandatory=$true)] $outFile
    )
    Invoke-WebRequest -uri $request -OutFile $outFile 

    Invoke-LogVerbose "Downloaded $request"
}
function Invoke-MsiInstaller{
    Param (
        [Parameter(Mandatory=$true)] $item,
        [Parameter(Mandatory=$true)] $logpath
    )
    $FileExists = Test-Path $item -IsValid
    $MSIArguments = @("/package $item", "/quiet", "/qn", "/norestart", "/log $logpath")
    If ($FileExists -eq $True)
    {
        Start-Process "msiexec.exe" -ArgumentList "$MSIArguments" -passthru | wait-process
        Invoke-LogVerbose "Finished msi $msifile"
    } 
    Else {Invoke-LogError "$itemFile doesn't exist"}
}
function Trace-ProxyValues($message, $Proxy, $NoProxy) {
    Invoke-LogVerbose $message
    Invoke-LogVerbose "`t- Proxy: $Proxy"
    Invoke-LogVerbose "`t- NoProxy: $NoProxy"
}
function Set-WindowsProxy($proxy, $bypassUrls) {
    $proxyBytes = [system.Text.Encoding]::ASCII.GetBytes($proxy)
    $bypassBytes = [system.Text.Encoding]::ASCII.GetBytes($bypassUrls)
    $defaultConnectionSettings = [byte[]]@(70,0,0,0,0,0,0,0,11,0,0,0,$proxyBytes.Length,0,0,0)+$proxyBytes+@($bypassBytes.Length,0,0,0)+$bypassBytes+ @(1..36 | % {0})
    $registryPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
    Check-RegistryPath($registryPath)
    Set-ItemProperty -Path $registryPath -Name ProxyServer -Value $proxy
    Set-ItemProperty -Path $registryPath -Name ProxyEnable -Value 1
    Set-ItemProperty -Path $registryPath -Name ProxyOverride -Value $bypassUrls
    Set-ItemProperty -Path "$registryPath\Connections" -Name DefaultConnectionSettings -Value $defaultConnectionSettings # Harmless fail on Server Core
    netsh winhttp set proxy $proxy bypass-list=$bypassUrls
}

function Check-RegistryPath($registryPath) {
    if (!(Get-ItemProperty -Path "$registryPath" -Name "ProxyServer" -ErrorAction SilentlyContinue)) {
        New-ItemProperty -Path "$registryPath" -Name "ProxyServer" -Value "1"
    }
    if (!(Get-ItemProperty -Path "$registryPath" -Name "ProxyEnable" -ErrorAction SilentlyContinue)) {
        New-ItemProperty -Path "$registryPath" -Name "ProxyEnable" -Value "1"
    }
    if (!(Get-ItemProperty -Path "$registryPath" -Name "ProxyOverride" -ErrorAction SilentlyContinue)) {
        New-ItemProperty -Path "$registryPath" -Name "ProxyOverride" -Value "1"
    }
    if (!(Test-Path "$registryPath\Connections")) {
        New-Item -Path "$registryPath" -Name "Connections"
    }
    if (!(Get-ItemProperty -Path "$registryPath\Connections" -Name "DefaultConnectionSettings" -ErrorAction SilentlyContinue)) {
        New-ItemProperty -Path "$registryPath\Connections" -Name "DefaultConnectionSettings" -Value ""
    }
}

function Set-SSMProxy($ProxyUrl) {
    $ProxyHost = ([System.Uri]$ProxyUrl).Host
    $ProxyPort = ([System.Uri]$ProxyUrl).Port
    $serviceKey = "HKLM:\SYSTEM\CurrentControlSet\Services\AmazonSSMAgent"
    $keyInfo = (Get-Item -Path $serviceKey).GetValue("Environment")
    $proxyVariables = @("http_proxy=${!ProxyHost}:${!ProxyPort}", "no_proxy=169.254.169.254")

    If($keyInfo -eq $null) {
        New-ItemProperty -Path $serviceKey -Name Environment -Value $proxyVariables -PropertyType MultiString -Force
    } else {
        Set-ItemProperty -Path $serviceKey -Name Environment -Value $proxyVariables
    }
}
# Pipeline Deployment Information
function Set-PipelineInfo {
    # Set Deployment information
    $DeploymentInformation = @"
# Generated by the pipeline

PIPELINE_AWS_REGION=${AWS::Region}
PIPELINE_AWS_ACCOUNT_ID=${AWS::AccountId}
PIPELINE_KMS_KEY_ARN=${KmsKeyArn}
PIPELINE_PORTFOLIO={{ context.Portfolio }}
PIPELINE_APP={{ context.App }}
PIPELINE_BRANCH={{ context.Branch }}
PIPELINE_BRANCH_SHORT_NAME={{ context.BranchShortName }}
PIPELINE_BUILD={{ context.Build }}
PIPELINE_BUCKET_NAME={{ context.FilesBucketName }}
PIPELINE_BUCKET_BUILD_PREFIX={{ context.BuildFilesPrefix }} 
"@

    $DeploymentInformationPs1 = @"
 # Generated by the pipeline

`$PIPELINE_REGION = `"${AWS::Region}`" 
`$PIPELINE_AWS_ACCOUNT_ID = `"${AWS::AccountId}`"  
`$PIPELINE_ENVIRONMENT = `"{{ context.Environment }}`" 
`$PIPELINE_KMS_KEY_ARN = `"${KmsKeyArn}`"  
`$PIPELINE_PORTFOLIO = `"{{ context.Portfolio }}`" 
`$PIPELINE_APP = `"{{ context.App }}`" 
`$PIPELINE_BRANCH = `"{{ context.Branch }}`"   
`$PIPELINE_BRANCH_SHORT_NAME = `"{{ context.BranchShortName }}`"   
`$PIPELINE_BUILD = `"{{ context.Build }}`"
`$PIPELINE_BUCKET_NAME = `"{{ context.FilesBucketName }}`"
`$PIPELINE_BUCKET_BUILD_PREFIX = `"{{ context.BuildFilesPrefix }}`"
`$PIPELINE_COMPONENT = `"{{ component_name }}`" 
"@
    if(!(Test-Path -Path "$ENV:SystemDrive\pipeline" )){
        New-Item -ItemType directory -Path "$ENV:SystemDrive\pipeline"
    }
    $DeploymentInformation | Out-File -FilePath "$ENV:SystemDrive\pipeline\deployment_information.txt" -Encoding UTF8
    $DeploymentInformationPs1 | Out-File -FilePath "$ENV:SystemDrive\pipeline\deployment_information.ps1"
}
{% endmacro %}